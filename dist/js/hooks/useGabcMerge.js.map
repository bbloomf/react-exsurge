{"version":3,"sources":["../../../src/hooks/useGabcMerge.tsx"],"names":["useGabcMerge","syllabifiedText","musicalNotation","useLargeInitial","normalizeInputs","text","notation","splitInputs","syllables","notationNodes","sylNdx","isFirstSyl","result","map","mapSyllable","syllable","nextIndex","isFirstSyllable","join","trim","length","replace","regexClef","regexNonSyllabicGabc","regexFindParensWithLeadSpaces","regexFindParens","split","filter","syl","stripParens","s","getSyllable","index","getNonSyllable","syllableNdx","test","noSyllable","nextSyllable","slice","capitalizeInitial","toUpperCase","toLowerCase"],"mappings":"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","sourcesContent":["export const useGabcMerge = (syllabifiedText: string, musicalNotation: string, useLargeInitial: boolean = true) => {\n\n  const { text, notation } = normalizeInputs(syllabifiedText, musicalNotation);\n\n  if (!text) return notation;\n  if (!notation) return text;\n\n  const { syllables, notationNodes } = splitInputs(text, notation);\n\n  let sylNdx = 0\n  let isFirstSyl = true;\n  let result = notationNodes\n    .map((notation) => {\n      const { syllable, nextIndex, isFirstSyllable } = mapSyllable(notation, syllables, sylNdx, isFirstSyl);\n      sylNdx = nextIndex;\n      isFirstSyl = isFirstSyllable;\n      return syllable;\n    })\n    .join('')\n    .trim()\n  ;\n\n  // add any additional syllables that come after the last notation data:\n  while (sylNdx < syllables.length) {\n    result +=\n      syllables[sylNdx++].replace(/^(\\s*)\"?\\(?(.*?)\\)?\"?$/, '$1$2') + '()';\n  }\n  return result;\n}\n\n/*-----  REGEX DEFS  -----*/\nconst regexClef = /^[cf]b?[1-4]$/;\nconst regexNonSyllabicGabc = /^([cf]b?[1-4]|[,;:`]+|[a-m]\\+|[zZ]0?)+$/;\nconst regexFindParensWithLeadSpaces = /^(\\s*)\\((.*)\\)$/;\nconst regexFindParens = /^\\((.*)\\)$/;\n\n/*-----  NORMALIZATION FUNCTIONS  -----*/\nconst normalizeInputs = (text: string, notation: string): { text: string, notation: string } => {\n  // normalize the text, getting rid of multiple consecutive whitespace,\n  // and handling lilypond's \\forceHyphen directive\n  text = text\n    .replace(/%[^\\n]*(\\n|$)/g, '$1')\n    .replace(/\\s*\\n\\s*/g, '\\n')\n    .replace(/(\\s)\\s+/g, '$1')\n    .replace(/\\\\forceHyphen\\s+(\\S+)\\s+--\\s+/g, '$1-')\n    .trim()\n  ;\n\n  notation = notation.replace(/%[^\\n]*(\\n|$)/g, '$1').trim();\n\n  return { text, notation }\n}\n\nconst splitInputs = (text: string, notation: string): { syllables: string[], notationNodes: string[] } => {\n  const syllables = text\n    .split(/\\s+--\\s+|\\+|(\\s*\\(?\"[^\"]+\"\\)?-?)|(?=\\s|(?<=[^\\s-]-)[^\\s-])/)\n    .filter((syl) => syl && syl.trim());\n\n  const notationNodes = notation.split(/\\s+/);\n\n  return { syllables, notationNodes };\n}\n\n/*-----  STRING UTIL FUNCTIONS  -----*/\nconst stripParens = (s: string) => {\n  return s.replace(regexFindParensWithLeadSpaces, '$1$2')\n      s.replace(regexFindParens, '$1')\n  ;\n}\n\n/*-----  GETTER FUNCTIONS  -----*/\nconst getSyllable = (syllables: string[], index: number) => {\n  return (syllables[index] || ' ').replace(/^(\\s*)\"(.*)\"$/, '$1$2');\n}\n\nconst getNonSyllable = (syllables: string[], syllableNdx: number, notation: string): string => {\n  let syllable = syllables[syllableNdx];\n\n  if (/^(\\s*!|[^a-záéíóúýàèìòùäëïöüÿæœǽœ́]+$|\\s*\\(.*\\)$|\\s*\"\\(.*\\)\"$)/i.test(syllable)\n      && !regexClef.test(notation)) {\n\n    return syllable.replace(/^(\\s*)!/, '$1')\n        .replace(/^(\\s*)\"?\\((.*?)\\)\"?$/, '$1$2')\n    ;\n  }\n\n  return ' ';\n}\n\n/*-----  PROCESSOR FUNCTIONS  -----*/\nconst mapSyllable = (\n  notation: string,\n  syllables: string[],\n  sylNdx: number,\n  isFirstSyllable: boolean\n): { syllable: string, nextIndex: number, isFirstSyllable: boolean } => {\n  const noSyllable = regexNonSyllabicGabc.test(notation) || /^\\(.*\\)$/.test(notation);\n  notation = stripParens(notation);\n\n  let syllable = noSyllable ? getNonSyllable(syllables, sylNdx, notation) : getSyllable(syllables, sylNdx++);\n  if (!noSyllable) {\n    let nextSyllable = syllable;\n    syllable = stripParens(syllable);\n\n    while (/^\\s*\\(.*\\)$/.test(nextSyllable)) {\n      if (/^\".*\"$/.test(syllable)) {\n        syllable = syllable.slice(1, -1);\n      }\n\n      nextSyllable = getSyllable(syllables, sylNdx++);\n      syllable += '()' + stripParens(nextSyllable);\n    }\n\n    if (isFirstSyllable) {\n      isFirstSyllable = false;\n\n      syllable = capitalizeInitial(syllable, syllables[sylNdx]);\n    }\n  }\n\n  syllable = syllable + '(' + notation + ')';\n\n  return { syllable, nextIndex: sylNdx, isFirstSyllable }\n}\n\nconst capitalizeInitial = (syllable: string, nextSyllable: string): string => {\n  if (/^\\s*[a-záéíóúýàèìòùäëïöüÿæœǽœ́]+/i.test(syllable)) {\n    // special capitalization rules for the large initial:\n    // the second letter should also be capitalized, and the third as well,\n    // if it is a three letter word\n    syllable = syllable.slice(0, 2).toUpperCase() + syllable.slice(2).toLowerCase();\n    if (syllable.length === 3 && /^\\s/.test(nextSyllable)) {\n      syllable = syllable.toUpperCase();\n    }\n  }\n\n  return syllable;\n}\n"],"file":"useGabcMerge.js"}